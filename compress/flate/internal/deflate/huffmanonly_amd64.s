// Code generated by command: go run main.go. DO NOT EDIT.

//go:build amd64 && !noasmtest

#include "textflag.h"

DATA rotate_perm<>+0(SB)/8, $0x0000000000000007
DATA rotate_perm<>+8(SB)/8, $0x0000000000000000
DATA rotate_perm<>+16(SB)/8, $0x0000000000000001
DATA rotate_perm<>+24(SB)/8, $0x0000000000000002
DATA rotate_perm<>+32(SB)/8, $0x0000000000000003
DATA rotate_perm<>+40(SB)/8, $0x0000000000000004
DATA rotate_perm<>+48(SB)/8, $0x0000000000000005
DATA rotate_perm<>+56(SB)/8, $0x0000000000000006
GLOBL rotate_perm<>(SB), RODATA, $64

// func encodeHuffmansArchV4(hist *histogram, input []byte, buf *BitBuf) int
// Requires: AVX, AVX512BW, AVX512DQ, AVX512F, AVX512VL
TEXT Â·encodeHuffmansArchV4(SB), NOSPLIT, $0-48
	// rotatePerm = rotate_perm
	VMOVDQU64 rotate_perm<>+0(SB), Z0

	// table = hist
	MOVQ hist+0(FP), AX
	MOVQ buf+32(FP), CX

	// output = buf.output
	MOVQ (CX), DX

	// outputEnd = output + len(buf.output) 
	MOVQ         8(CX), BX
	CMPQ         BX, $0x00000038
	JBE          skip
	ADDQ         DX, BX
	MOVQ         24(CX), SI
	ADDQ         SI, DX
	MOVQ         32(CX), SI
	MOVQ         40(CX), CX
	MOVQ         input_base+8(FP), DI
	MOVQ         input_len+16(FP), R8
	CMPQ         R8, $0x00000020
	JBE          skip
	LEAQ         (DI)(R8*1), R8
	SUBQ         $0x00000020, R8
	SUBQ         $0x00000038, BX
	KXORQ        K0, K0, K0
	MOVQ         $0x5555555555555555, R9
	KMOVQ        R9, K1
	MOVQ         $0x00000000fffffff0, R9
	KMOVQ        R9, K2
	MOVQ         $0x00000000fffffffc, R9
	KMOVQ        R9, K3
	MOVQ         $0x0101010101010101, R9
	KMOVQ        R9, K4
	MOVQ         $0x00000000fffffffe, R9
	KMOVQ        R9, K5
	MOVQ         $0x0000000000000007, R9
	VPBROADCASTQ R9, Z1
	VPTERNLOGD   $0x55, Z1, Z2, Z2

	// litMask = 0x3ff
	MOVL         $0x000003ff, R9
	VPBROADCASTD R9, Z3

	// distMask = 0x1ff
	MOVL         $0x000001ff, R9
	VPBROADCASTD R9, Z3

	// litCodeMask = 0xff_ff_ff
	MOVL         $0x00ffffff, R9
	VPBROADCASTD R9, Z3

	// extraBitCountMask = 0xff
	MOVL         $0x000000ff, R9
	VPBROADCASTD R9, Z9
	KNOTQ        K0, K4

	// tokens = load512(tokenPtr)
	VMOVDQU64   (DI), X9
	VPMOVZXBD.Z X9, K4, Z9

	// litlenHuffcodes = hufftable[symbols]
	VPGATHERDD 124(AX)(Z9*4), K4, Z4
	KNOTQ      K0, K4

	// bits = fn.bits
	VMOVQ SI, X5

	// bitsLen = fn.bitsLen
	VMOVQ CX, X6

loop:
	// litLenCodeLens = litlenHuffcodes >> 24
	// litLenCodes = litlenHuffcodes & 0xff_ff_ff
	VPSRLD $0x18, Z4, Z11
	VPANDD Z3, Z4, Z10

	// if output == outputEnd { break loop}
	CMPQ DX, BX
	JA   output_end

	// ; prepare for next iteration
	ADDQ  $0x00000010, DI
	KNOTQ K0, K4

	// tokens = load512(tokenPtr)
	VMOVDQU64   (DI), X9
	VPMOVZXBD.Z X9, K4, Z9

	// litlenHuffcodes = hufftable[symbols]
	VPGATHERDD 124(AX)(Z9*4), K4, Z4
	KNOTQ      K0, K4
	VMOVDQA32  Z11, Z12

	// tempBits = keepEvenItems(litLenCodes) 
	VMOVDQA32.Z Z10, K1, Z9

	// litLenCodes_64 >>= 32
	VPSRLQ $0x20, Z10, Z10

	// litLenCodeLens = tempLens >> 32
	VPSRLQ $0x20, Z12, Z11

	// tempLens = keepEvenItems(tempLens)
	VMOVDQA32.Z Z12, K1, Z12

	// ; Merge tempBits and existed bits
	// tempBits = (tempBits << bitsCount) | bits
	VPSLLVQ Z6, Z9, Z9
	VPORQ   Z5, Z9, Z9

	// tempLens += bitsCount
	VPADDQ Z6, Z12, Z12

	// ; Merge tempBits and odd-indexed codes
	// litLenCodes = (litLenCodes << tempLens) | tempBits
	VPSLLVQ Z12, Z10, Z10
	VPORQ   Z10, Z9, Z10

	// litLenCodeLens += tempLens
	VPADDQ       Z11, Z12, Z11
	VPXORQ       Z7, Z7, Z7
	VPERMQ       Z11, Z0, K5, Z7
	VPADDQ       Z7, Z11, Z9
	VSHUFI64X2.Z $0x90, Z9, Z9, K3, Z7
	VPADDQ       Z7, Z9, Z9
	VSHUFI64X2.Z $0x40, Z9, Z9, K2, Z7
	VPADDQ       Z7, Z9, Z9
	VPANDQ       Z1, Z9, Z6
	VPERMQ.Z     Z6, Z0, K5, Z5
	VPSLLVQ      Z5, Z10, Z10
	VPCMPQ       $0x01, Z6, Z11, K5, K6
	VPSRLQ       $0x03, Z9, Z9
	VPADDQ       Z5, Z11, Z11
	VPANDQ       Z2, Z11, Z11
	KNOTQ        K0, K4
	VPSRLVQ      Z11, Z10, K4, Z8
	KTESTD       K6, K6
	JNZ          merge_bytes

small_code_write_out:
	KNOTQ         K5, K7
	VPERMQ.Z      Z8, Z0, K7, Z5
	VPERMQ.Z      Z6, Z0, K7, Z6
	VPERMQ.Z      Z8, Z0, K5, Z8
	VPXORD        Z8, Z10, Z10
	VEXTRACTI64X2 $0x03, Z9, X11
	VPEXTRQ       $0x01, X11, CX
	KNOTQ         K0, K6
	VPERMQ.Z      Z9, Z0, K5, Z9
	VPSCATTERQQ   Z10, K6, (DX)(Z9*1)
	ADDQ          CX, DX
	CMPQ          DI, R8
	JBE           loop

output_end:
	VMOVQ X6, CX
	VMOVQ X5, SI
	JMP   finish

merge_bytes:
	VPERMQ.Z Z8, Z0, K6, Z5
	VPORQ    Z8, Z5, Z8
	KSHIFTLQ $0x01, K6, K7
	KTESTD   K6, K7
	JZ       small_code_write_out
	KANDQ    K6, K7, K6
	JMP      merge_bytes

finish:
	MOVQ buf+32(FP), AX
	MOVQ SI, 32(AX)
	MOVQ CX, 40(AX)
	MOVQ (AX), CX
	SUBQ CX, DX
	MOVQ DX, 24(AX)
	MOVQ input_base+8(FP), AX
	SUBQ AX, DI
	MOVQ DI, ret+40(FP)
	RET

skip:
	MOVQ $0x00000000, AX
	MOVQ AX, ret+40(FP)
	RET
